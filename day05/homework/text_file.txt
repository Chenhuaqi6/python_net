进程创建

import os
pid = os.fork()
功能:创建新的进程
返回值:失败 返回一个负数 
      成功 原进程中返回新进程的pid号
          新进程中返回 0
作业:理解fork的使用

*父进程执行fork 子进程从fork下面执行

*父子进程各自独立运行,运行顺序不一定

* if 结构几乎是fork的固定搭配通过父子进程返回值的区别使其执行不同的代码

*子进程会复制父进程全部代码段和内存空间,包括fork前所开辟的空间

*父子进程空间互不影响,各自修改各自空间内容

*子进程也有自己的独立内容,比如,pid,指令集, pcb 等

进程函数
os.getpid()
功能:获取当前进程的PID号
返回值:返回PID

os.getppid()
功能:获取父进程的PID号
返回值: 返回pid号

os._exit(status)
功能:退出进程
参数: 整数  表示进程的退出状态


sys.exit([status])
功能:退出进程
参数:整数  表示进程退出状态,默认为0
    字符串  表示进程退出时打印该字串

孤儿进程:父进程先于子进程退出,此时子进程就成为孤儿进程

*孤儿进程会被系统收养,即该系统进程称为孤儿进程新的父进程

僵尸进程 : 子进程先于父进程退出,且父进程没有处理子进程的退出行为,此时子进程就会成为僵尸进程

*僵尸进程虽然结束但是会存留部分进程信息在内存中,大量的僵尸进程会消耗系统资源,因此应该避免僵尸进程的产生

如何处理僵尸进程:
    *二级子进程

    pid,status = os.wait()
    功能:父进程中阻塞等待处理子进程的退出
    返回值:pid 退出的子进程的pid号
          status 子进程的退出状态
    


    pid,status = os.waitpid(pid,option)
    功能:父进程中等待处理子进程的退出
    参数: pid -1表示等待任意子进程退出 
             >0 表示等待对应pid的子进程退出
         option  0 表示阻塞等待
                 os.WNOHANG 表示非阻塞
    返回值:pid 退出的子进程的pid号
          status 子进程的退出状态

++++++++++++++++++++++++++++++++++++
群聊聊天室
功能:类似qq群聊
1.进入聊天室需要输入姓名,姓名不能重复
2.进入聊天室会向其他成员发送通知
   xxx 进入了聊天室 
3.一个人发消息,其他人都会收到
   xxx 说: xxxxxxxxxxxxx
4.某人退出聊天室,其他人也会收到通知
   xxx 退出了聊天室
5.管理员可以从服务端发送消息,此时群里人都收的到
    管理员说xxxxxxxx

技术分析

发消息(udp套接字)
成员存储:服务端 {name:addr} [(name,addr),(name,addr)]
消息发送模式: 转发,消息先发送给服务器,服务器转发给其他成员
管理员:服务端 发送内容,其他人接收
保证收发消息互不影响:使用多进程

整体设计
1.封装方式
2.编写流程 先确保通信实现 逐个功能实现
3.测试 实现一个功能测试一个功能

具体功能实现:
    网络通信
        服务端:创建udp套接字
        客户端:创建套接字